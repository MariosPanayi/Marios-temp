source('~/GitHub/Marios-temp/NIDA_Expts/Experiments/MPNIDA001_Pilots/scripts/Plot_2_CRF.R', echo=TRUE)
A_on_1 <- seq(from = 1, to = 10, by = 1)
A_off_1 <- seq(from = 2, to = 11, by = 1)
A_on <- seq(from = 1, to = 10, by = 1)
A_off <- seq(from = 2, to = 11, by = 1)
A_on <- seq(from = 1, to = 10, by = 1)
A_off <- seq(from = 2, to = 11, by = 1)
A_on <- c(1,2,2,4,6,8,10)
A_off <- c(2,5,7,9,11,12)
# Make sure data are in chronological order!!! Otherwise loop will go on forever
A_on <- sort(A_on)
A_off <- sort(A_off)
if (is_empty(A_on) & !is_empty(A_off)) {
# Check to see if there are no ON signals
# Situation - special case where event initiated prior to recording start
A_on <- c(0,A_on)
}
if (!is_empty(A_on) & is_empty(A_off)) {
# Check to see if there are no OFF signals
# Situation - special case where OFF signal occurred within temporal resolution of system for first response
A_off <- c(A_on[1], A_off)
}
if (A_on[1] > A_off[1]) {
# Check to see if the first event is an Off. Assumption is that the on signal happened before recording started.
# Artificially set the action initiation as time = 0 (i.e. session start)
A_on <- c(0,A_on)
}
# Combine all on and off signals and order them by time AND [A_on before A_off] when there is a tie
# [we will deal with issues this might cause, but it will be correct most of the time]
time = c(A_on, A_off)
event = c(rep("A_on", length(A_on)), rep("A_off", length(A_off)))
# Event ID is just a numeric version of even 1 = On, 2 = Off
eventID = c(rep(1, length(A_on)), rep(2, length(A_off)))
#  Order data
A = data.frame(time, event, eventID)
A = setorder(A, time, eventID)
# Delete eventID to save memory
A <- A[, c("time","event")]
# Add a numeric order to the list so we can manipulate values later
A$eventorder = c(1:nrow(A))
# Check for sequential times that are tied for more than 1 event
# N.B. if ties[i] = 0, then that event[i] and event[i+1] happened at the same time
ties = diff(A$time)
ties = which(ties == 0)
# If there are ties to consider
if (length(ties) != 0) {
# Test to ignore first tie if it is also the first event
if(ties[1] == 1) {j = 2} else {j = 1}
for(i in c(j:length(ties))){
idx = ties[i]
if((A$event[idx-1] == "A_on" & A$event[idx] == "A_on" &  A$event[idx+1] == "A_off")) {
# If the tied A_on and A_off signals are in the wrong order, switch them around
# Note that this is the only way they can be ordered incorrectly since:
# 1) We have already ordered the data so any times that are tied will put an A_on before an A_off
# 2) Coulbourn never records more than 1x A_on and 1x A_off with the same time
# 3) If the previous A_on had a simultaneous A_off then it would also be recorded as such
A$eventorder[idx] = idx+1
A$eventorder[idx+1] = idx
# Important to re-order the data after each change in case multiple ties are adjacent to each other
A = setorder(A, eventorder)
}
# clear unused temporary variables for memory efficiency
rm(ties,event,time, A_on, A_off)
view(A)
A_on <- c(1,2,2,4,6,8,10)
A_off <- c(2,5,7,9,11,12)
# Make sure data are in chronological order!!! Otherwise loop will go on forever
A_on <- sort(A_on)
A_off <- sort(A_off)
if (is_empty(A_on) & !is_empty(A_off)) {
# Check to see if there are no ON signals
# Situation - special case where event initiated prior to recording start
A_on <- c(0,A_on)
}
if (!is_empty(A_on) & is_empty(A_off)) {
# Check to see if there are no OFF signals
# Situation - special case where OFF signal occurred within temporal resolution of system for first response
A_off <- c(A_on[1], A_off)
}
if (A_on[1] > A_off[1]) {
# Check to see if the first event is an Off. Assumption is that the on signal happened before recording started.
# Artificially set the action initiation as time = 0 (i.e. session start)
A_on <- c(0,A_on)
}
# Combine all on and off signals and order them by time AND [A_on before A_off] when there is a tie
# [we will deal with issues this might cause, but it will be correct most of the time]
time = c(A_on, A_off)
event = c(rep("A_on", length(A_on)), rep("A_off", length(A_off)))
# Event ID is just a numeric version of even 1 = On, 2 = Off
eventID = c(rep(1, length(A_on)), rep(2, length(A_off)))
#  Order data
A = data.frame(time, event, eventID)
A = setorder(A, time, eventID)
# Add a numeric order to the list so we can manipulate values later
A$eventorder = c(1:nrow(A))
# Check for sequential times that are tied for more than 1 event
# N.B. if ties[i] = 0, then that event[i] and event[i+1] happened at the same time
ties = diff(A$time)
ties = which(ties == 0)
# If there are ties to consider
if (length(ties) != 0) {
# Test to ignore first tie if it is also the first event
if(ties[1] == 1) {j = 2} else {j = 1}
for(i in c(j:length(ties))){
idx = ties[i]
if((A$event[idx-1] == "A_on" & A$event[idx] == "A_on" &  A$event[idx+1] == "A_off")) {
# If the tied A_on and A_off signals are in the wrong order, switch them around
# Note that this is the only way they can be ordered incorrectly since:
# 1) We have already ordered the data so any times that are tied will put an A_on before an A_off
# 2) Coulbourn never records more than 1x A_on and 1x A_off with the same time
# 3) If the previous A_on had a simultaneous A_off then it would also be recorded as such
A$eventorder[idx] = idx+1
A$eventorder[idx+1] = idx
# Important to re-order the data after each change in case multiple ties are adjacent to each other
A = setorder(A, eventorder)
}
# clear unused temporary variables for memory efficiency
rm(ties,event,time, A_on, A_off)
diff(A$eventID)
diff(A$event)
A$eventID
repeats <- diff(A$eventID)
repeats <- which(repeats == 0)
repeats
reopeats_ID <- A$event[repeats]
repeats_ID <- A$event[repeats]
repeats_ID
-1 - -1
A_on <- c(1,2,2,4,6,8,10)
A_off <- c(2,5,7,9,11,12)
# Make sure data are in chronological order!!! Otherwise loop will go on forever
A_on <- sort(A_on)
A_off <- sort(A_off)
if (is_empty(A_on) & !is_empty(A_off)) {
# Check to see if there are no ON signals
# Situation - special case where event initiated prior to recording start
A_on <- c(0,A_on)
}
if (!is_empty(A_on) & is_empty(A_off)) {
# Check to see if there are no OFF signals
# Situation - special case where OFF signal occurred within temporal resolution of system for first response
A_off <- c(A_on[1], A_off)
}
if (A_on[1] > A_off[1]) {
# Check to see if the first event is an Off. Assumption is that the on signal happened before recording started.
# Artificially set the action initiation as time = 0 (i.e. session start)
A_on <- c(0,A_on)
}
# Combine all on and off signals and order them by time AND [A_on before A_off] when there is a tie
# [we will deal with issues this might cause, but it will be correct most of the time]
time = c(A_on, A_off)
event = c(rep("A_on", length(A_on)), rep("A_off", length(A_off)))
# Event ID is just a numeric version of even -1 = On, 1 = Off
eventID = c(rep(-1, length(A_on)), rep(1, length(A_off)))
#  Order data
A = data.frame(time, event, eventID)
A = setorder(A, time, eventID)
# Add a numeric order to the list so we can manipulate values later
A$eventorder = c(1:nrow(A))
A
# Check for sequential times that are tied for more than 1 event
# N.B. if ties[i] = 0, then that event[i] and event[i+1] happened at the same time
ties = diff(A$time)
ties = which(ties == 0)
# If there are ties to consider
if (length(ties) != 0) {
# Test to ignore first tie if it is also the first event
if(ties[1] == 1) {j = 2} else {j = 1}
for(i in c(j:length(ties))){
idx = ties[i]
if((A$event[idx-1] == "A_on" & A$event[idx] == "A_on" &  A$event[idx+1] == "A_off")) {
# If the tied A_on and A_off signals are in the wrong order, switch them around
# Note that this is the only way they can be ordered incorrectly since:
# 1) We have already ordered the data so any times that are tied will put an A_on before an A_off
# 2) Coulbourn never records more than 1x A_on and 1x A_off with the same time
# 3) If the previous A_on had a simultaneous A_off then it would also be recorded as such
A$eventorder[idx] = idx+1
A$eventorder[idx+1] = idx
# Important to re-order the data after each change in case multiple ties are adjacent to each other
A = setorder(A, eventorder)
}
A
repeats <- diff(A$eventID)
repeats <- which(repeats == 0)
repeats_ID <- A$eventID[repeats]
repeats
repeats_ID
replacements <- data.table(repeats_ID = c(-1, 1), add_event = c("A_off", "A_on"))
replacements
repeats_ID
setkey(repeats_ID,replacements)
testdata <- data.table(repeats, repeats_ID)
replacements <- data.table(repeats_ID = c(-1, 1), add_event = c("A_off", "A_on"))
setkey(testdata,replacements)
setkey(testdata,repeats_ID)
testdata
setkey(replacements,repeats_ID)
replacements
testdata[replacements, add_event]
testdata[replacements, repeats_ID := add_event]
repeats_ID = c(-1, 1)
add_event = c("A_off", "A_on")
testdata[replacements, repeats_ID := add_event]
setkey(testdata,repeats_ID)
setkey(replacements,repeats_ID)
testdata[replacements, repeats_ID := add_event]
testdata
testdata <- data.table(repeats, repeats_ID)
replacements <- data.table(
repeats_ID = c(-1, 1),
extra_event = c("A_off", "A_on")
)
testdata[replacements, repeats_ID := extra_event, on =. (repeats_ID)][]
repeats_ID <- A$event[repeats]
testdata <- data.table(repeats, repeats_ID)
repeats <- diff(A$eventID)
repeats <- which(repeats == 0)
repeats_ID <- A$event[repeats]
testdata <- data.table(repeats, repeats_ID)
replacements <- data.table(
repeats_ID = c("A_on", "A_off"),
extra_event = c("A_off", "A_on")
)
testdata[replacements, repeats_ID := extra_event, on =. (repeats_ID)][]
repeats_ID
testdata[replacements, repeats_ID := extra_event, on =. (repeats_ID)]
testdata
testdata <- data.table(repeats, repeats_ID, extra_event = repeats_ID)
testdata
repeats <- diff(A$eventID)
repeats <- which(repeats == 0)
repeats_ID <- A$event[repeats]
testdata <- data.table(repeats, repeats_ID, extra_event = repeats_ID)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
testdata[replacements, extra_event := newvalues, on =. (extra_event =  oldvalues)]
repeats <- diff(A$eventID)
repeats <- which(repeats == 0)
repeats_ID <- A$event[repeats]
testdata <- data.table(repeats, repeats_ID, extra_event = repeats_ID)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
testdata[recodeData, extra_event := newvalues, on =. (extra_event =  oldvalues)]
testdata
repeats <- diff(A$eventID)
repeatsidx <- which(repeats == 0)
repeats_ID <- A$event[repeatsidx]
testdata <- data.table(repeatsidx, repeats_ID, extra_event = repeats_ID)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
testdata[recodeData, extra_event := newvalues, on =. (extra_event =  oldvalues)]
testdata
repeats <- diff(A$eventID)
repeatsidx <- which(repeats == 0)
repeats_ID <- A$event[repeatsidx]
extra_time <- A$time[repeatsidx]
extra_eventorder <- A$eventorder[repeatsidx]
A_extra <- data.table(repeatsidx, repeats_ID, extra_time, extra_eventorder, extra_event = repeats_ID)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
A_extra[recodeData, extra_event := newvalues, on =. (extra_event =  oldvalues)]
A_extra
repeats <- diff(A$eventID)
repeatsidx <- which(repeats == 0)
repeats_ID <- A$event[repeatsidx]
extra_time <- A$time[repeatsidx]
extra_eventorder <- A$eventorder[repeatsidx] + 0.5
A_extra <- data.table(repeatsidx, repeats_ID, extra_time, extra_eventorder, extra_event = repeats_ID)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
A_extra[recodeData, extra_event := newvalues, on =. (extra_event =  oldvalues)]
A_extra
# a value of 0 indicates that this index and the one above it are the same [i.e. two A_on or two A_off in a row]
repeats <- diff(A$eventID)
# Indices in A of first repeat value
repeatsidx <- which(repeats == 0)
# Identity of the repeated event name
repeats_ID <- A$event[repeatsidx]
# Time of the first repeated event
extra_time <- A$time[repeatsidx]
# New position to insert extra event between repeats
extra_eventorder <- A$eventorder[repeatsidx] + 0.5
# Create datatable and recode the new event identities
A_extra <- data.table(repeatsidx, repeats_ID, extra_time, extra_event = repeats_ID, extra_eventorder)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
# Recode data to reflect the correct identity of the extra events to insert
A_extra[recodeData, extra_event := newvalues, on =. (extra_event =  oldvalues)]
# Drop unnecessary variables
A_extra <- A_extra[, c("extra_time","extra_event", "extra_eventorder")]
# Relabel columns to merge with A data
colnames(A_extra) <- c("time","event", "eventorder")
# Join with original data
A <- A[, c("time","event", "eventorder")]
A <- rbindlist(list(A, A_extra), use.names = TRUE)
# Re organise the data in correct temporal order
A <- setorder(A, eventorder)
A
nrow(A)
A$event[nrow(A)]
coulbourn_actioncleantimestamps2 <- function(A_on, A_off) {
# Function takes a vector of Action ON times and a vector of Action OFF times from a session
# Data are processed to fix any issues with missing/non-matching ON/OFF times
# Assumptions made are that:
# 1) If an action OFF signal is the first timestamp, then the first action ON was before the session started (so first A_On set to time = 0)
# 2) Any ON or OFF signal that is doesn't pair chronologically with the other signals reflects an action ON/OFF signal occuring faster than the temporal resolution of the system
#   A corresponding On/Off signal is added so that the ON-OFF duration is 0 (i.e. they occurred at the same time)
# These issues happen surprisingly often for Coulbourn Lever Pressing data in particular
# N.B. output is a data frame of A_on and A_off, split this output apart for use with other functions.
if (length(A_on) > 0 | length(A_off) > 0) {
# Make sure data are in chronological order!!! Otherwise loop will go on forever
A_on <- sort(A_on)
A_off <- sort(A_off)
if (is_empty(A_on) & !is_empty(A_off)) {
# Check to see if there are no ON signals
# Situation - special case where event initiated prior to recording start
A_on <- c(0,A_on)
}
if (!is_empty(A_on) & is_empty(A_off)) {
# Check to see if there are no OFF signals
# Situation - special case where OFF signal occurred within temporal resolution of system for first response
A_off <- c(A_on[1], A_off)
}
if (A_on[1] > A_off[1]) {
# Check to see if the first event is an Off. Assumption is that the on signal happened before recording started.
# Artificially set the action initiation as time = 0 (i.e. session start)
A_on <- c(0,A_on)
}
# Combine all on and off signals and order them by time AND [A_on before A_off] when there is a tie
# [we will deal with issues this might cause, but it will be correct most of the time]
time = c(A_on, A_off)
event = c(rep("A_on", length(A_on)), rep("A_off", length(A_off)))
# Event ID is just a numeric version of even -1 = On, 1 = Off
eventID = c(rep(-1, length(A_on)), rep(1, length(A_off)))
#  Order data
A = data.frame(time, event, eventID)
A = setorder(A, time, eventID)
# Add a numeric order to the list so we can manipulate values later
A$eventorder = c(1:nrow(A))
# Check for sequential times that are tied for more than 1 event
# N.B. if ties[i] = 0, then that event[i] and event[i+1] happened at the same time
ties = diff(A$time)
ties = which(ties == 0)
# If there are ties to consider
if (length(ties) != 0) {
# Test to ignore first tie if it is also the first event
if(ties[1] == 1) {j = 2} else {j = 1}
for(i in c(j:length(ties))){
idx = ties[i]
if((A$event[idx-1] == "A_on" & A$event[idx] == "A_on" &  A$event[idx+1] == "A_off")) {
# If the tied A_on and A_off signals are in the wrong order, switch them around
# Note that this is the only way they can be ordered incorrectly since:
# 1) We have already ordered the data so any times that are tied will put an A_on before an A_off
# 2) Coulbourn never records more than 1x A_on and 1x A_off with the same time
# 3) If the previous A_on had a simultaneous A_off then it would also be recorded as such
A$eventorder[idx] = idx+1
A$eventorder[idx+1] = idx
# Important to re-order the data after each change in case multiple ties are adjacent to each other
A = setorder(A, eventorder)
}
# clear unused temporary variables for memory efficiency
rm(ties,event,time, A_on, A_off)
# a value of 0 indicates that this index and the one above it are the same [i.e. two A_on or two A_off in a row]
repeats <- diff(A$eventID)
# Indices in A of first repeat value
repeatsidx <- which(repeats == 0)
# Identity of the repeated event name
repeats_ID <- A$event[repeatsidx]
# Time of the first repeated event
extra_time <- A$time[repeatsidx]
# New position to insert extra event between repeats
extra_eventorder <- A$eventorder[repeatsidx] + 0.5
# Create datatable and recode the new event identities
A_extra <- data.table(repeatsidx, repeats_ID, extra_time, extra_event = repeats_ID, extra_eventorder)
recodeData <- data.table(
oldvalues = c("A_on", "A_off"),
newvalues = c("A_off", "A_on")
)
# Recode data to reflect the correct identity of the extra events to insert
A_extra[recodeData, extra_event := newvalues, on =. (extra_event =  oldvalues)]
# Drop unnecessary variables
A_extra <- A_extra[, c("extra_time","extra_event", "extra_eventorder")]
# Relabel columns to merge with A data
colnames(A_extra) <- c("time","event", "eventorder")
# Join with original data
A <- A[, c("time","event", "eventorder")]
A <- rbindlist(list(A, A_extra), use.names = TRUE)
# Re organise the data in correct temporal order
A <- setorder(A, eventorder)
# One last check to make sure final event is an OFF signal
if (A$event[nrow(A)] == "A_on") {
# Create extra data and append to A
A_final <- data.frame(time = A$time[nrow(A)],
event = "A_off",
eventorder = (A$eventorder[nrow(A)] + 0.5))
A <- rbindlist(list(A, A_final), use.names = TRUE)
A <- setorder(A, eventorder)
}
### Extract data and return function output
A_on = A$time[A$event == "A_on"]
A_off = A$time[A$event == "A_off"]
A_data <- data.frame(A_on, A_off)
return(A_data)
# End Data re-ordering
} else {
A_data <- data.frame(A_on, A_off)
return(A_data)
}
A_on_1 <- seq(from = 1, to = 1006, by = 2)
A_off_1 <- seq(from = 2, to = 1001, by = 2)
coulbourn_actioncleantimestamps2(A_on_1, A_off_1)
source('~/GitHub/Marios-temp/NIDA_Expts/Experiments/MPNIDA001_Pilots/scripts/coulbourn_actioncleantimestamps_Development_Temp.R', echo=TRUE)
A_while <- "While_1000_Rand" = coulbourn_actioncleantimestamps(A_on_rand, A_off_rand)
A_For <- "For_1000_Rand" = coulbourn_actioncleantimestamps1(A_on_rand, A_off_rand)
A_None <- "None_1000_Rand" = coulbourn_actioncleantimestamps2(A_on_rand, A_off_rand)
A_while <- coulbourn_actioncleantimestamps(A_on_rand, A_off_rand)
A_For <- coulbourn_actioncleantimestamps1(A_on_rand, A_off_rand)
A_None <- coulbourn_actioncleantimestamps2(A_on_rand, A_off_rand)
A_while - A_For
A_while - A_None
A_For - A_None
sum(A_while - A_For)
sum(A_while - A_None)
sum(A_For - A_None)
sum(A_while - A_None)
A_on_rand <- round(runif(length(A_on_1), min=0, max=1000), digits = 2)
A_off_rand <- round(runif(length(A_off_1), min=0, max=1000), digits = 2)
A_while <- coulbourn_actioncleantimestamps(A_on_rand, A_off_rand)
A_For <- coulbourn_actioncleantimestamps1(A_on_rand, A_off_rand)
A_None <- coulbourn_actioncleantimestamps2(A_on_rand, A_off_rand)
sum(A_while - A_None)
sum(A_while - A_For)
sum(A_For - A_None)
A_For - A_None
head(A_For - A_None)
# Load Packagaes ----------------------------------------------------------
## Packages for data organisation and plotting
library(tidyverse)
library(knitr)
library(data.table)
# Package for relative file paths
library(here)
# Benchmark time of functions
library(microbenchmark)
# Load Analysis Functions
source(here("scripts", "CoulbournAnalysisFunctions.R"))
# Packages for parallel computing
library(foreach)
library(doParallel)
numCores = 8
registerDoParallel(numCores)
# Identify files to analyze
## COllapses multiple subfolders if needed
### Project specific folder
projectdatafolder <- c("rawdata","Marios","1_SpecificCI")
## Final level of folders contianing the relevant .txt Coulbourn files
listofdatafolders <- c("RetardationTest_Stage5_Day16",
"RetardationTest_Stage5_Day17",
"RetardationTest_Stage5_Day18",
"RetardationTest_Stage5_Day19",
"RetardationTest_Stage5_Day20")
#  extract data filenames, only .txt --------------------------------------
Coulbourn_extractIndividualSubjectFiles(projectdatafolder, listofdatafolders)
#  extract processed data filenames, only .csv and put them into a --------
########## Set parameters ############
processdata <- function(projectdatafolder, listofdatafolders) {
## List of states
S = c("ITI" = 1,
"PreCS" = 2,
"Flash" = 3,
"Steady" = 4,
"Pel_Banana" = 5,
"Pel_Chocolate" = 7,
"End" = 6)
## Time base the linc was set to, in ms
timebase = 20
## Time bins to analyze each state in, in s
timebinwidth = 1
## States to bin and which not to bin
nobin = c(S["ITI"], S["End"])
bin = c(S["PreCS"], S["Flash"], S["Steady"],S["Pel_Banana"], S["Pel_Chocolate"])
## Identify state that trials start in, usually the ITI ;)
trialstartstate = S["ITI"]
########## Run Analysis ############
for (i in c(1:length(listofdatafolders))){
lookup <- paste(c(projectdatafolder, listofdatafolders[i]), collapse = "/")
datafilepaths <- list.files(path = lookup, pattern = ".csv")
foreach (j = c(1:length(datafilepaths))) %dopar% {
library(here)
library(tidyverse)
library(knitr)
library(data.table)
source(here("scripts", "CoulbournAnalysisFunctions.R"))
# For each raw.txt file split up the data into individual subjects .csv files for subsequent analysis
folderpath <- here(paste(projectdatafolder, collapse = "/"),listofdatafolders[i])
filename <- datafilepaths[j]
## Run Function - N.B. Warnings will appear to tell you that the new directory for data storage already exists. Safe to ignore.
coulbourn_processdata_Pavlovian_timebin(filename,folderpath,S,timebase, timebinwidth, nobin, bin, trialstartstate)
}
microbenchmark(processdata(projectdatafolder, listofdatafolders), times = 1)
