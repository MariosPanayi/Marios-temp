function [simData,confidenceRawData]=confidenceModel(data,fitresult,varargin)
% simulates confidence values for some percepts and a given generative model
% with specified parameters
% inputs
% data- table with following columns
%       'evidence' and 'mapping' for simulation of confidence
%       'confidence' (optional) for matching simulated confidence to observed
%       confidence, if not specified no matching will be performed
% fitresult- a modelfit object generated by PsychometricModel.m with the
% generative function and the fitted parameters
%
% options
% 'type' - 'analytical' uses analytical Method to derive the
%           posterior probability of being correct (e.g., Lak et al. 2014,
%           Neuron)
%           'bootstrap' uses bootstrap method (Sanders et al.,
%           Neuron) to derive the posterior probability of being correct
%           'distance' uses the distance of the percept from the boundary
% 'genModel' - 'gaussian' one-parameter Gaussian (default), other options are 
%           'guessGaussian','symmetricLapseGaussian','guessLapseGaussian'
%           and do simulate lapses as random choices
% 'perceptBin' -  binning method tto bootstrap the average probability of
%           being correct (only relevant for 'bootstrap' type)
%           'equalSpace' bins simulated percepts into 200 equally spaced
%           bins 'equalFill' bins simulated percepts into 200 equally
%           filled bins
% 'nsim'    -  number of simulations for each trial 
% 'plotMatch' - plots the match between simulated confidence (probability)
%           and observed confidence (e.g., time investments)
%           can be false (no plot) or true (plot in new figure, default) or
%           axes handles (plot in axes handle)
% 'plotMatchStyle' - plots either horizontal histogram (regular) or vertical
%           histogram with fancy color line (fancy)
% 'alpha'    confidence noise parameter, percentage of trials where
%           confidence is assumed to be random, see (Sanders et al.,
%           Neuron) and Masset et al. 2020, Cell for details
% 'oddEvidence' that is the evidence that is assumed for 'oddtrials', this is used for
%           setting the evidence on no-signal trials to the value that best describes
%           the choice behavior
% 
% KS March 2019 schmack@cshl.edu

%% let's parse our inputs
p=inputParser;
validTable = @(x) istable(x) & sum(ismember(x.Properties.VariableNames,{'evidence','mapping'}))==2;
p.addRequired('data', validTable);
p.addRequired('fitresult',@isobject);
p.addParameter('type','analytic',@(x) any(validatestring(x,{'analytic','bootstrap','distance'})));
p.addParameter('genModel','gaussian',@(x) any(validatestring(x,{'gaussian','guessGaussian','symmetricLapseGaussian','guessLapseGaussian'})));
p.addParameter('perceptBin','equalSpace',@(x) any(validatestring(x,{'equalSpace','equalFill'})));
p.addParameter('nsim',1E2,@(x) validateattributes(x,{'numeric'},{'scalar'}));
p.addParameter('plotMatch',true,@(x) islogical(x)|isgraphics(x));
p.addParameter('plotMatchStyle','regular');% fancy: vertical histogram
p.addParameter('fancyColor',[1 .6 .2]); % fancy: orange line
p.addParameter('alpha',1,@isnumeric);% noise parameter 
p.addParameter('oddEvidence',-20,@isnumeric);
p.parse(data,fitresult,varargin{:})

% remove options out of structure for faster performance
for fn=fieldnames(p.Results)'
    eval([ (fn{1}) 'Option=p.Results.' fn{1} ';']);
end
data.realEvidence=data.evidence;%to save real evidence when using oddEvidenc for simulations
if any(ismember(data.Properties.VariableNames,'oddtrial'))
    data.evidence(data.oddtrial)=oddEvidenceOption;
end

%% simulate choice behavior
% prepare
x=data.evidence;
percept=nan(nsimOption,length(x));
evidence=nan(nsimOption,length(x));
mapping=nan(nsimOption,length(x),2);
realEvidence=nan(nsimOption,length(x));

%% first let's simulate percepts based on the psychometric fit parameters
for t=1:length(x)
    percept(:,t)=normrnd(x(t),fitresult.sigma,[nsimOption 1]);
    evidence(:,t)=repmat(x(t),[nsimOption 1]);
    realEvidence(:,t)=repmat(data.realEvidence(t),[nsimOption 1]);
    mapping(:,t,1)=repmat(data.mapping(t,1),[nsimOption 1]);
    mapping(:,t,2)=repmat(data.mapping(t,2),[nsimOption 1]);
end
percept=reshape(percept,[nsimOption*length(x) 1]);
evidence=reshape(evidence,[nsimOption*length(x) 1]);
realEvidence=reshape(realEvidence,[nsimOption*length(x) 1]);
mapping=reshape(mapping,[nsimOption*length(x) 2]);


%% now let's derive the choices based on the percepts
% choice is determined by internal estimation of boundary = fitresult.m
choice=(percept-fitresult.m)>0;

% add random choices for percepts at boundary
randChoiceIdx=percept==fitresult.m;
choice(randChoiceIdx)=randsample([true false],sum(randChoiceIdx),1);

% add guesses and lapses if specified by model
if ismember(genModelOption,{'guessGaussian','guessLapseGaussian'})
    noiseFdx=find(choice==0);
    noiseFdx=noiseFdx(randperm(length(noiseFdx)));
    guessNumber=floor(fitresult.gamma*length(noiseFdx));
    choice(noiseFdx(1:guessNumber))=true(guessNumber,1);
end

if ismember(genModelOption,{'guessLapseGaussian'})
    signalFdx=find(choice==1);
    signalFdx=signalFdx(randperm(length(signalFdx)));
    lapseNumber=floor(fitresult.lamda*length(signalFdx));
    choice(signalFdx(1:lapseNumber))=false(lapseNumber,1);
end

if ismember(genModelOption,{'symmetricLapseGaussian'})
    trialFdx=1:length(choice);
    trialFdx=trialFdx(randperm(length(trialFdx)));
    lapseNumber=2*floor(fitresult.lapse*length(choice));
    choice(trialFdx(1:lapseNumber))=choice(trialFdx(1:lapseNumber))==false;% toggle choices on lapse trials
end

%% now let's determine outcome based on data.mapping
outcome=nan(nsimOption*length(x),1);
for c=1:length(choice)
    rewProbablity=mapping(c,choice(c)+1);
    outcome(c)=randsample([1 0],1,1,[rewProbablity 1-rewProbablity]);
end

%% and finally, let's calculate the probability of being correct for each simulated trial
switch typeOption
    case {'analytic'}
        confidenceRaw=nan(size(percept));
        % if percept right of boundary, take integral of generative model
        % [percept Inf]
        rightIdx=percept>fitresult.m;
        confidenceRaw(rightIdx)=normcdf(percept(rightIdx),fitresult.m,fitresult.sigma);
        % if percept left of fitresult.m, take 1-integral of generative model
        % [-Inf percept]
        leftIdx=percept<fitresult.m;
        confidenceRaw(leftIdx)=1-normcdf(percept(leftIdx),fitresult.m,fitresult.sigma);
        % if percept equals boundary, set confidence to .5
        boundIdx=percept==fitresult.m;
        confidenceRaw(boundIdx)=.5;        
    case {'distance'}
        confidenceRaw=abs(percept-fitresult.m);
    case {'bootstrap'}%consider using some of matlab's numerical integration algorithms (trapz, integrate, quad)
        nBinsPercept=200;
        switch  perceptBinOption
            case {'equalSpace'}
                binEdges=linspace(min(percept),max(percept),nBinsPercept);
            case {'equalFill'}
                binEdges=[prctile(percept,linspace(0,100,nBinsPercept)) max(percept)+.01];
        end
        zeroBins=histcounts(percept,binEdges)==0;
        binEdges(zeroBins)=[];
        binPerceptIdx=discretize(percept,binEdges);%binning percepts
        confidencesAverage=grpstats(outcome,binPerceptIdx,'mean');
        confidenceRaw=confidencesAverage(binPerceptIdx);
end


%% add confidence noise: alpha
if alphaOption<1
    confidenceRaw=alphaOption.*confidenceRaw+(1-alphaOption).*randsample(confidenceRaw,length(confidenceRaw),true);
end

%% take into consideration catch trials
% expand confidences from correct trials to account for catchtrials (this
% makes better use of the data, but adds some irrelevant because of randsample)
if any(ismember(data.Properties.VariableNames,'catchtrial'))
    OmissionIdx = (data.catchtrial==1&data.outcome==1);
    FillIdx = (data.catchtrial==0&data.outcome==1);
    data.confidence(FillIdx)=randsample(data.confidence(OmissionIdx),sum(FillIdx),true);
else
    FillIdx=false(height(data),1);
end

% % shrink confidences from incorrect trials to account for number
% catchtrials (this is removes a lot of useful data, but leads to 100%
% reproducibility at this step)
% if any(ismember(data.Properties.VariableNames,'catchtrial'))
%     DownFactor=sum(data.catchtrial==0&data.outcome==1)./sum(data.outcome==1);
%     RemoveFdx=find(data.outcome==0);
%     RemoveFdx=RemoveFdx(randperm(length(RemoveFdx)));
%     RemoveFdx=RemoveFdx(1:ceil(DownFactor*length(RemoveFdx)));
%     data.confidence(RemoveFdx)=nan;
% end

%% resample simulated confidence so it has the same distribution as the observed confidence values
if any(ismember(data.Properties.VariableNames,'confidence'))
    % define dsitributions to match
    cobs=data.confidence(~isnan(data.confidence));
    csim=confidenceRaw;
    
    % bin distributions in 100 prctiles
    cobsEdge=(prctile(cobs,linspace(0,100,1e2)));
    cobsCenter=cobsEdge(1:end-1)+diff(cobsEdge);
    csimEdge=unique(prctile(csim,linspace(0,100,1e2)));
    
    % transform simulated distribution into observed distribution
    csimBins=discretize(csim,csimEdge);
    confidence=cobsCenter(csimBins)';
    
    % transform observed confidence into simulated distribution
    if nargout>1
        csimCenter=csimEdge(1:end-1)+diff(csimEdge);
        cobsBins=discretize(cobs,cobsEdge);
        confidenceRawData=nan(height(data),1);
        cobsBins(cobsBins>length(csimCenter))=length(csimCenter);%hack to deal with too many confidences=1
        confidenceRawData(~isnan(data.confidence))=csimCenter(cobsBins)';
        confidenceRawData(FillIdx)=nan;
    end
    
    % determine if distributions should be plotted
    if ~isgraphics(plotMatchOption)&&plotMatchOption
        figure;
        h=subplot(1,1,1);
        hold(h);
        weWillPlot=true;
    elseif isgraphics(plotMatchOption)
        h=plotMatchOption;
        if ~ishold(h)
            hold(h);
        end
        weWillPlot=true;
    else
        weWillPlot=false;
    end
    
    % plot if specified
    if weWillPlot
        switch plotMatchStyleOption
            case 'regular'
                [y,x]=histcounts(cobs(~isnan(cobs)),'Normalization','probability');
                a=bar(h,x(1:end-1)+diff(x)/2,y,'EdgeColor','none','FaceColor',[.2,.2,.2]);
                [y,x]=histcounts(confidence(~isnan(confidence)),x,'Normalization','probability');
                b=plot(h,x(1:end-1)+diff(x)/2,y,'Color',[.7,.7,.7],'LineWidth',2);
                xlabel('confidence')
                l=legend([a,b],{'data','model'},'Location','northwest');
                l.Box='off';
                l.ItemTokenSize=[10 25];
            case 'fancy'
                [y1,x1]=histcounts(cobs(~isnan(cobs)),'Normalization','pdf');
                a=barh(h,x1(1:end-1)+diff(x1)/2,y1+.4,'BaseValue',.4,'EdgeColor','none','FaceColor',[.4 .4 .4]);
                [y2,x2]=histcounts(confidence(~isnan(confidence)),x1,'Normalization','cdf');                
                b=plot(h,rescale(y2,.4,1),x2(1:end-1)+diff(x2)/2,'Color',fancyColorOption,'LineWidth',2);
                ylabel('Invested time (s)')
                xlabel('Confidence')                
                l=legend([a,b],{'data','model'},'Location','northwest');
                l.Box='off';
                l.ItemTokenSize=[10 25];                
        end
    end
else
    confidence=confidenceRaw;
end

% assemble data into output table
simData=table(percept,evidence,realEvidence,choice,outcome,confidenceRaw,confidence);
end




